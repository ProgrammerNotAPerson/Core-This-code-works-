#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pb,             sensorNone)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    G2,             sensorGyro)
#pragma config(Sensor, in4,    G3,             sensorGyro)
#pragma config(Sensor, in5,    AccX,           sensorAccelerometer)
#pragma config(Sensor, in6,    AccY,           sensorAccelerometer)
#pragma config(Sensor, dgtl1,  led,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  bottomT,        sensorTouch)
#pragma config(Sensor, dgtl3,  bottomL,        sensorTouch)
#pragma config(Sensor, I2C_1,  F1,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  F2,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           E,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           F1,            tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           F2,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           A,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          A2,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "ShooterCode.c"//older version of the shooter code header file
#include "Acquisition.h"
void stop (){//function to easily stop the robot during autonomous
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;}
float GAvg;
void GyroRead (){
	float Gyro1 =	SensorValue[G2]/10;//scale readings by ten as the gyro returns values of 10 ticks per degree
	float Gyro2 = SensorValue[G3]/10;
	float GBias1 = Gyro1*1.27;//use the gyro bias to calculate true reading
	float GBias2 = Gyro2*1.24;
	GAvg = (GBias1+GBias2)/2;}//set variable
task GyroProcess (){//use a task to constantly update gyro reading
	while(true){
		GyroRead();}
}
/*task Record (){//This allows us to check for Gyro Drift before a match
	while(true){//Lian does this function look ok
		string GyroReading = "%f",GAvg;
		displayLCDString(0,16,GAvg);
		delay(20);}}*/
int X2 = 0, Y1 = 0, X1 = 0, threshold = 30;
void pre_auton()
{

	bStopTasksBetweenModes = true;
  SensorValue(G2)=0;
	SensorValue(G3)=0;
	motor[servo]=0;
	power=true;
	wait1Msec(250);
	clearTimer(T1);
	//startTask(Record);
}
task autonomous()//currently our autonomous shoots the four driver control loads with close to perfect accuracy
{
	 SensorValue(G2)=0;
	 SensorValue(G3)=0;
	 motor[servo]=0;
	 power=false;
	startTask(FlywheelA);
	startTask(Acquisition);
	//startTask(Record);
	startTask(speedControlBottom);
	startTask(speedControlTop);
	startTask(GyroProcess);
	startTask(LED);
	wait1Msec(500);
	clearTimer(T2);
	while(time1[T2]<8000){//Shoots for eight seconds which allows for all the balls to fire and then some as our
		if(speedSet==true&&speedSetB==true){//shooting speed is about 1.3 seconds per ball
			wait1Msec(200);
			TriggerA();
		}
	}
	while(GAvg<15){//turns 15 degrees towards ball stack
		motor[frontRight] = 50;
		motor[backRight] = 50;
		motor[frontLeft] = -50;
		motor[backLeft] = -50;}
	stop();
	motor[frontRight] = 127;//goes until it is about midway to the field and has picked up an average of two balls
	motor[backRight] = 127;
	motor[frontLeft] = 127;
	motor[backLeft] = 127;
	wait1Msec(3000);
	stop();
	while(GAvg>-6){//turns to align with the goal
	motor[frontRight] = -50;
	motor[backRight] = -50;
	motor[frontLeft] = 50;
	motor[backLeft] = 50;}
	stop();
}
task usercontrol()
{
	motor[servo]=0;//sets servo trigger to cocked back position
	power=true;
	startTask(speedControlBottom);//begins speed control task which houses the code for our algorithm
	startTask(speedControlTop);
	//startTask(Record);
	startTask(LED);//LED indicator for driver
	startTask(AutoA);
	startTask(FlywheelA);
	while (true)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3])> threshold || abs(vexRT[Ch3Xmtr2]) > threshold){
			Y1 = vexRT[Ch3] + ((vexRT[Ch3Xmtr2])/2);
		}
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold){
			X1 = vexRT[Ch4];
		}
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1])> threshold || abs(vexRT[Ch1Xmtr2]) > threshold){
			X2 = vexRT[Ch1]+((vexRT[Ch1Xmtr2])/2);//allows for the scaled turning of the robot for shooting by second driver
		}
		else
			X2 = 0;
		motor[frontRight] =  Y1 - X2 - X1;//code to control drive
		motor[backRight] =  Y1 - X2 + X1;
		motor[frontLeft] = Y1 + X2 - X1;
		motor[backLeft] = Y1 + X2 + X1;
		if(vexRT[Btn7U]==1){
			power=false;}
		if(vexRT[Btn7D]==1){
			power=true;}
		if(vexRT[Btn8UXmtr2]==1){//zone 8
			startTask(Flywheel8);}
		if(vexRT[Btn8RXmtr2]==1){//zone 7
			startTask(Flywheel7);}
		if(vexRT[Btn8DXmtr2]==1){//zone 6
			startTask(Flywheel6);}
		if(vexRT[Btn8LXmtr2]==1){//zone 5
			startTask(Flywheel5);}
		if(vexRT[Btn7UXmtr2]==1){//zone 4
			startTask(Flywheel4);}
		if(vexRT[Btn7RXmtr2]==1){//zone 3
			startTask(Flywheel3);}
		if(vexRT[Btn7DXmtr2]==1){//zone2
			startTask(Flywheel2);}
		if(vexRT[Btn5UXmtr2]==1){//terminate
			startTask(FlywheelS);}
		if(vexRT[Btn6UXmtr2]==1){
			startTask(Trigger);}
		if(vexRT[Btn6U]==1){//this uses an on-off type switch to control acquisition
			startTask(Acquisition);}
		if(vexRT[Btn6D]==1){
			startTask(AcquisitionS);}
		if(vexRT[Btn8U]==1){//lift control based on two limit switches
			powerE=1;}
		if(vexRT[Btn8D]==1){
			powerE=2;}
		if(vexRT[Btn8D]==0&&vexRT[Btn8U]==0){
			powerE=0;}
		switch (powerE) {//uses a switch statement to prcess joystick presses
		case 1:
			if(SensorValue(bottomT)==0){
				motor[E]=-127;}
			else{
				motor[E]=0;}
			break;
		case 2:
			if(SensorValue(bottomL)==0){
				motor[E]=127;}
			else{
				motor[E]=0;}
			break;
		case 0:
			motor[E]=0;
			break;
		}
	}
}
