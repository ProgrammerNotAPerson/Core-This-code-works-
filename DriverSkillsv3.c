#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pb,             sensorNone)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    G2,             sensorGyro)
#pragma config(Sensor, in4,    G3,             sensorGyro)
#pragma config(Sensor, in5,    AccX,           sensorAccelerometer)
#pragma config(Sensor, in6,    AccY,           sensorAccelerometer)
#pragma config(Sensor, dgtl1,  led,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  bottomT,        sensorTouch)
#pragma config(Sensor, dgtl3,  bottomL,        sensorTouch)
#pragma config(Sensor, I2C_1,  F1,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  F2,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           E,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           F1,            tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           F2,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           A,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          A2,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)
int X2 = 0, Y1 = 0, X1 = 0, threshold = 30;
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)
#include "ShooterCode.c"
#include "Acquisition.h"
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



void pre_auton()
{
  bStopTasksBetweenModes = true;
	motor[servo]=0;
	wait1Msec(250);
	clearTimer(T1);
	power=false;

}



task autonomous()
{

}

task usercontrol()
{
	motor[servo]=0;//sets servo trigger to cocked back position
	startTask(speedControlBottom);
	startTask(speedControlTop);
	startTask(LED);
	startTask(AutoA);
	startTask(FlywheelA);
	while (true)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3])> threshold || abs(vexRT[Ch3Xmtr2]) > threshold){
			Y1 = vexRT[Ch3] + ((vexRT[Ch3Xmtr2])/2);
		}
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold){
			X1 = vexRT[Ch4];
		}
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1])> threshold || abs(vexRT[Ch1Xmtr2]) > threshold){
			X2 = vexRT[Ch1]+((vexRT[Ch1Xmtr2])/4);//allows for the scaled turning of the robot for shooting by second driver
		}
		else
			X2 = 0;
			motor[frontRight] =  Y1 - X2 - X1;//code to control drive
			motor[backRight] =  Y1 - X2 + X1;
			motor[frontLeft] = Y1 + X2 - X1;
			motor[backLeft] = Y1 + X2 + X1;
	if(vexRT[Btn7U]==1){
		power=false;}
	if(vexRT[Btn7D]==1){
		power=true;}
	if(vexRT[Btn8UXmtr2]==1){//zone 8
			startTask(Flywheel8);}
	if(vexRT[Btn8RXmtr2]==1){//zone 7
			startTask(Flywheel7);}
	if(vexRT[Btn8DXmtr2]==1){//zone 6
			startTask(Flywheel6);}
	if(vexRT[Btn8LXmtr2]==1){//zone 5
			startTask(Flywheel5);}
	if(vexRT[Btn7UXmtr2]==1){//zone 4
			startTask(Flywheel4);}
	if(vexRT[Btn7RXmtr2]==1){//zone 3
			startTask(Flywheel3);}
	if(vexRT[Btn7DXmtr2]==1){//zone2
			startTask(Flywheel2);}
	if(vexRT[Btn5UXmtr2]==1){//terminate
			startTask(FlywheelS);}
	if(vexRT[Btn6UXmtr2]==1){
		startTask(Trigger);}
		if(vexRT[Btn6U]==1){//this uses an on-off type switch to control acquisition
			startTask(Acquisition);}
		if(vexRT[Btn6D]==1){
			startTask(AcquisitionS);}
	}
}
